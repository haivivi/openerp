"""ios_ui_test — run XCUITest against a Bazel-built iOS app.

Strategy:
  1. Bazel builds the .app bundle (via ios_app rule).
  2. This rule generates a temporary Xcode project for the UI tests.
  3. xcodebuild compiles the XCUITest bundle and runs it on the simulator.

This approach avoids the XCTest framework compilation issues in Bazel's
Swift toolchain while keeping the test source in the Bazel workspace.
"""

def _ios_ui_runner_impl(ctx):
    # Collect the .app directory from ios_app dep.
    app_dir = None
    bundle_id = ctx.attr.app_bundle_id
    for dep in ctx.attr.app:
        if DefaultInfo in dep:
            for f in dep[DefaultInfo].files.to_list():
                if f.path.endswith(".app"):
                    app_dir = f

    if not app_dir:
        fail("ios_ui_runner: no .app found in deps")

    test_sources = ctx.files.test_srcs

    # Generate runner script.
    runner = ctx.actions.declare_file(ctx.label.name + ".sh")

    # Build paths for test source files.
    src_copies = []
    for f in test_sources:
        if f.path.endswith(".swift"):
            src_copies.append("cp '{}' \"$WORKDIR/UITests/\"".format(f.path))

    runner_content = """\
#!/bin/bash
set -euo pipefail

APP_PATH="{app_path}"
BUNDLE_ID="{bundle_id}"
WORKDIR=$(mktemp -d)
trap "rm -rf $WORKDIR" EXIT

echo "=== Flux XCUITest Runner ==="

# Copy app to temp (fix permissions).
APP_COPY="$WORKDIR/App.app"
cp -r "$APP_PATH" "$APP_COPY"
chmod -R u+w "$APP_COPY"
xattr -cr "$APP_COPY" 2>/dev/null || true
codesign --force --sign - --deep --timestamp=none "$APP_COPY"

# Copy test sources.
mkdir -p "$WORKDIR/UITests"
{src_copies}

# Generate minimal Xcode project for xcodebuild.
PROJ_DIR="$WORKDIR/UITestProject.xcodeproj"
mkdir -p "$PROJ_DIR"

cat > "$PROJ_DIR/project.pbxproj" << 'PBXPROJ'
// Minimal pbxproj — just enough for xcodebuild to compile and run XCUITests.
// This is auto-generated by the Bazel ios_ui_runner rule.
{{
    archiveVersion = 1;
    objectVersion = 56;
    rootObject = ROOT;
    objects = {{
        ROOT = {{ isa = PBXProject; buildConfigurationList = CFGLIST; mainGroup = MAIN; targets = (TEST_TARGET); }};
        MAIN = {{ isa = PBXGroup; children = (SRC_GROUP); sourceTree = "<group>"; }};
        SRC_GROUP = {{ isa = PBXGroup; children = (); path = UITests; sourceTree = "<group>"; }};
        CFGLIST = {{ isa = XCConfigurationList; buildConfigurations = (CFG); }};
        CFG = {{ isa = XCBuildConfiguration; name = Debug; buildSettings = {{
            SDKROOT = iphonesimulator;
            SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
            SWIFT_VERSION = 5.0;
            IPHONEOS_DEPLOYMENT_TARGET = 18.0;
        }}; }};
        TEST_TARGET = {{ isa = PBXNativeTarget; name = UITests; buildConfigurationList = TEST_CFGLIST; buildPhases = (SOURCES_PHASE); productType = "com.apple.product-type.bundle.ui-testing"; }};
        TEST_CFGLIST = {{ isa = XCConfigurationList; buildConfigurations = (TEST_CFG); }};
        TEST_CFG = {{ isa = XCBuildConfiguration; name = Debug; buildSettings = {{
            PRODUCT_BUNDLE_IDENTIFIER = "{bundle_id}.uitests";
            TEST_TARGET_NAME = App;
            TEST_HOST = "";
            INFOPLIST_FILE = "";
        }}; }};
        SOURCES_PHASE = {{ isa = PBXSourcesBuildPhase; files = (); }};
    }};
}}
PBXPROJ

# Find a booted simulator.
DEVICE_ID=$(xcrun simctl list devices booted -j | python3 -c "
import json, sys
data = json.load(sys.stdin)
for runtime, devices in data.get('devices', {{}}).items():
    for d in devices:
        if d.get('state') == 'Booted':
            print(d['udid'])
            sys.exit(0)
print('')
")

if [ -z "$DEVICE_ID" ]; then
    echo "ERROR: No booted simulator. Boot one: xcrun simctl boot <UDID>"
    exit 1
fi
echo "Simulator: $DEVICE_ID"

# Install app.
xcrun simctl install "$DEVICE_ID" "$APP_COPY"
echo "App installed: $BUNDLE_ID"

# Compile and run tests using swiftc directly.
SDK_PATH=$(xcrun --sdk iphonesimulator --show-sdk-path)
PLATFORM_DIR=$(xcrun --sdk iphonesimulator --show-sdk-platform-path)
XCTEST_FW="$PLATFORM_DIR/Developer/Library/Frameworks"
SWIFT_LIB=$(dirname $(xcrun --toolchain default --find swiftc))/../lib/swift/iphonesimulator

echo "Compiling XCUITest bundle..."
XCTEST_OUT="$WORKDIR/UITests.xctest"
mkdir -p "$XCTEST_OUT"

# Compile Swift test files into a bundle.
xcrun --sdk iphonesimulator swiftc \
    -target arm64-apple-ios18.0-simulator \
    -F "$XCTEST_FW" \
    -framework XCTest \
    -I "$XCTEST_FW/XCTest.framework/Headers" \
    -emit-library \
    -o "$XCTEST_OUT/UITests" \
    -module-name TwitterFluxUITests \
    $WORKDIR/UITests/*.swift \
    2>&1 || {{ echo "Swift compilation failed"; exit 1; }}

# Create Info.plist for xctest bundle.
cat > "$XCTEST_OUT/Info.plist" << PLIST
<?xml version="1.0" encoding="UTF-8"?>
<plist version="1.0"><dict>
<key>CFBundleIdentifier</key><string>{bundle_id}.uitests</string>
<key>CFBundleExecutable</key><string>UITests</string>
<key>CFBundlePackageType</key><string>BNDL</string>
</dict></plist>
PLIST

codesign --force --sign - --timestamp=none "$XCTEST_OUT"

echo "Running XCUITests..."
xcrun simctl spawn "$DEVICE_ID" xctest "$XCTEST_OUT" 2>&1 || true

echo "=== XCUITest complete ==="
""".format(
        app_path = app_dir.path,
        bundle_id = bundle_id,
        src_copies = "\n".join(src_copies),
    )

    ctx.actions.write(
        output = runner,
        content = runner_content,
        is_executable = True,
    )

    return [
        DefaultInfo(
            files = depset([runner]),
            executable = runner,
            runfiles = ctx.runfiles(files = [app_dir] + test_sources),
        ),
    ]

ios_ui_runner = rule(
    implementation = _ios_ui_runner_impl,
    attrs = {
        "app": attr.label_list(mandatory = True),
        "test_srcs": attr.label_list(allow_files = [".swift"]),
        "app_bundle_id": attr.string(mandatory = True),
    },
    executable = True,
)
