//! OpenERP DSL types.
//!
//! Two categories:
//!
//! 1. **Field** — compile-time field reference for store trait consts.
//!    Generated by `#[model]` as `Self::field_name`.
//!
//! 2. **Semantic newtypes** — String wrappers that carry meaning
//!    (Id, Email, Avatar, etc.). Type name -> UI widget mapping.
//!
//! Usage:
//! ```ignore
//! use openerp_types::*;
//!
//! #[model(module = "auth")]
//! pub struct User {
//!     pub id: Id,
//!     pub email: Option<Email>,
//! }
//!
//! impl KvStore for User {
//!     const KEY: Field = Self::id;
//!     const UNIQUE: &[Field] = &[Self::email];
//! }
//! ```

pub mod format;

pub use format::{
    create_string_vector, vt_offset, FlatBufferDecodeError, Format, FromFlatBuffer,
    FromFlatBufferList, IntoFlatBuffer, IntoFlatBufferList, MIME_FLATBUFFERS, MIME_JSON,
};

use serde::{de::DeserializeOwned, Deserialize, Serialize};
use std::fmt;
use std::ops::Deref;

// ── DslModel trait ──

/// Marker trait for models generated by `#[model]`.
///
/// Provides compile-time metadata (module, resource name, URL path)
/// that the client and server use to derive API routes automatically.
///
/// Generated by `#[model(module = "auth")]`:
/// ```ignore
/// impl DslModel for User {
///     fn module() -> &'static str { "auth" }
///     fn resource() -> &'static str { "user" }
///     fn resource_path() -> &'static str { "users" }
/// }
/// ```
pub trait DslModel: Serialize + DeserializeOwned + Clone + Send + Sync + 'static {
    /// Module name (e.g. "auth", "pms", "task").
    fn module() -> &'static str;
    /// Singular resource name (e.g. "user", "device").
    fn resource() -> &'static str;
    /// Plural URL path segment (e.g. "users", "devices").
    fn resource_path() -> &'static str;
}

// ── DslEnum trait ──

/// Marker trait for enums generated by `#[dsl_enum]`.
///
/// Provides variant names for schema/UI (select widget) and the module
/// the enum belongs to.  Serialized as SCREAMING_SNAKE_CASE strings so
/// existing KV data (`"DRAFT"`, `"IN_PROGRESS"`) stays compatible.
pub trait DslEnum:
    Serialize + DeserializeOwned + Clone + Send + Sync + fmt::Display + std::str::FromStr + Default + 'static
{
    /// Module this enum belongs to (e.g. "pms", "task").
    fn module() -> &'static str;
    /// Enum type name (e.g. "BatchStatus").
    fn enum_name() -> &'static str;
    /// All variant names as SCREAMING_SNAKE_CASE strings.
    fn variants() -> &'static [&'static str];
}

// ── Field reference ──

/// A compile-time field reference. Generated by `#[model]` as associated consts.
///
/// Used in store trait impls to specify KEY, UNIQUE, INDEX fields
/// with compile-time checking (typo = compile error).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Field {
    /// Field name as it appears in the Rust struct.
    pub name: &'static str,
    /// Rust type name (e.g. "String", "Id", "Option<Email>").
    pub ty: &'static str,
    /// UI widget hint inferred from the type.
    pub widget: &'static str,
}

impl Field {
    pub const fn new(name: &'static str, ty: &'static str, widget: &'static str) -> Self {
        Self { name, ty, widget }
    }
}

impl fmt::Display for Field {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.name)
    }
}

/// Map a type name to a UI widget string. Used by the `#[model]` macro.
pub const fn widget_for_type(ty: &str) -> &str {
    // const fn can't do string matching in stable Rust, so the macro
    // will call a non-const helper. This is a placeholder.
    "text"
}

/// Known DSL builtin type names — anything not in this set that starts
/// with an uppercase letter is assumed to be a `#[dsl_enum]` → `"select"`.
///
/// **Must stay in sync with `openerp_macro::model::BUILTIN_TYPES`.**
/// Duplicated here because proc-macro crates cannot depend on runtime crates.
const BUILTIN_TYPES: &[&str] = &[
    "Id", "Email", "Phone", "Url", "Avatar", "ImageUrl",
    "Password", "PasswordHash", "Secret",
    "Text", "Markdown", "Code",
    "DateTime", "Date", "Color", "SemVer",
    "String", "bool", "u8", "u16", "u32", "u64", "i8", "i16", "i32", "i64",
    "f32", "f64", "Vec",
];

/// Non-const widget inference from type name.
///
/// **Must stay in sync with `openerp_macro::model::infer_widget`.**
/// Duplicated here because proc-macro crates cannot depend on runtime crates.
pub fn infer_widget(ty_name: &str, field_name: &str) -> &'static str {
    match ty_name {
        "Id" => "readonly",
        "Email" => "email",
        "Phone" => "tel",
        "Url" => "url",
        "Avatar" | "ImageUrl" => "image",
        "Password" => "password",
        "PasswordHash" | "Secret" => "hidden",
        "Text" => "textarea",
        "Markdown" => "markdown",
        "Code" => "code",
        "DateTime" => "datetime",
        "Date" => "date",
        "Color" => "color",
        "SemVer" => "text",
        "bool" => "switch",
        "Vec" => "tags",
        _ => {
            if field_name.ends_with("_at") { return "datetime"; }
            if field_name == "description" || field_name == "notes" { return "textarea"; }
            if is_enum_type(ty_name) { return "select"; }
            "text"
        }
    }
}

/// Heuristic: a type name that starts uppercase and isn't a known builtin
/// is treated as a `#[dsl_enum]` → select widget.
///
/// **Must stay in sync with `openerp_macro::model::is_enum_type`.**
pub fn is_enum_type(ty_name: &str) -> bool {
    ty_name.starts_with(|c: char| c.is_ascii_uppercase()) && !BUILTIN_TYPES.contains(&ty_name)
}

/// Macro to define a newtype wrapper around String.
macro_rules! string_newtype {
    ($(#[$meta:meta])* $name:ident) => {
        $(#[$meta])*
        #[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        #[serde(transparent)]
        pub struct $name(pub String);

        impl $name {
            pub fn new(s: impl Into<String>) -> Self {
                Self(s.into())
            }

            pub fn as_str(&self) -> &str {
                &self.0
            }

            pub fn into_inner(self) -> String {
                self.0
            }

            pub fn is_empty(&self) -> bool {
                self.0.is_empty()
            }
        }

        impl Deref for $name {
            type Target = str;
            fn deref(&self) -> &str {
                &self.0
            }
        }

        impl fmt::Display for $name {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str(&self.0)
            }
        }

        impl From<String> for $name {
            fn from(s: String) -> Self {
                Self(s)
            }
        }

        impl From<&str> for $name {
            fn from(s: &str) -> Self {
                Self(s.to_string())
            }
        }

        impl Default for $name {
            fn default() -> Self {
                Self(String::new())
            }
        }
    };
}

// ── Identity types ──

string_newtype!(
    /// Unique identifier (UUID v4, no dashes).
    /// UI: read-only text, auto-generated.
    Id
);

// ── Contact types ──

string_newtype!(
    /// Email address.
    /// UI: email input with validation.
    Email
);

string_newtype!(
    /// Phone number (E.164 format).
    /// UI: tel input.
    Phone
);

// ── URL types ──

string_newtype!(
    /// A URL / hyperlink.
    /// UI: url input with validation.
    Url
);

string_newtype!(
    /// Avatar image URL.
    /// UI: image upload / preview.
    Avatar
);

string_newtype!(
    /// Generic image URL.
    /// UI: image upload / preview.
    ImageUrl
);

// ── Secret types ──

string_newtype!(
    /// A password (plaintext, for input only — never stored as-is).
    /// UI: password input (masked). Never returned in API responses.
    Password
);

string_newtype!(
    /// A hashed password (argon2/bcrypt). Stored in DB.
    /// UI: hidden (never shown).
    PasswordHash
);

string_newtype!(
    /// A secret token or API key.
    /// UI: password input. Masked in API responses.
    Secret
);

// ── Text types ──

string_newtype!(
    /// Multi-line text / description.
    /// UI: textarea.
    Text
);

string_newtype!(
    /// Markdown-formatted content.
    /// UI: markdown editor.
    Markdown
);

string_newtype!(
    /// Code / JSON content.
    /// UI: code editor with syntax highlighting.
    Code
);

// ── Date/time types ──

string_newtype!(
    /// RFC 3339 datetime string.
    /// UI: datetime picker.
    DateTime
);

string_newtype!(
    /// Date string (YYYY-MM-DD).
    /// UI: date picker.
    Date
);

// ── Misc types ──

string_newtype!(
    /// CSS hex color value (e.g. #ff0000).
    /// UI: color picker.
    Color
);

string_newtype!(
    /// Semantic version string (e.g. 1.2.3).
    /// UI: text input with version format hint.
    SemVer
);

// ── Pluralization ──

/// Simple English pluralization for URL paths.
///
/// Handles common cases:
///   policy → policies, batch → batches, device → devices,
///   relay → relays, user → users, bus → buses
pub fn pluralize(s: &str) -> String {
    if s.ends_with('y') {
        // Consonant + y → ies (policy → policies)
        // Vowel + y → ys (relay → relays, day → days)
        let chars: Vec<char> = s.chars().collect();
        if chars.len() >= 2 {
            let before_y = chars[chars.len() - 2];
            if !"aeiou".contains(before_y) {
                return format!("{}ies", &s[..s.len() - 1]);
            }
        }
        format!("{}s", s)
    } else if s.ends_with('s') || s.ends_with('x') || s.ends_with('z')
        || s.ends_with("sh") || s.ends_with("ch")
    {
        format!("{}es", s)
    } else {
        format!("{}s", s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn transparent_serde() {
        let email = Email::new("alice@test.com");
        let json = serde_json::to_string(&email).unwrap();
        assert_eq!(json, "\"alice@test.com\"");

        let back: Email = serde_json::from_str(&json).unwrap();
        assert_eq!(back.as_str(), "alice@test.com");
    }

    #[test]
    fn option_serde() {
        let avatar: Option<Avatar> = Some(Avatar::new("https://img.test/a.png"));
        let json = serde_json::to_string(&avatar).unwrap();
        assert_eq!(json, "\"https://img.test/a.png\"");

        let none: Option<Avatar> = None;
        let json = serde_json::to_string(&none).unwrap();
        assert_eq!(json, "null");
    }

    #[test]
    fn deref_and_display() {
        let url = Url::new("https://example.com");
        assert_eq!(url.len(), 19); // Deref to str
        assert_eq!(format!("{}", url), "https://example.com");
    }

    #[test]
    fn default_is_empty() {
        assert!(Id::default().is_empty());
        assert!(Email::default().is_empty());
    }

    #[test]
    fn from_conversions() {
        let e: Email = "test@test.com".into();
        assert_eq!(e.as_str(), "test@test.com");

        let e2: Email = String::from("foo@bar.com").into();
        assert_eq!(e2.as_str(), "foo@bar.com");
    }

    #[test]
    fn pluralize_common_cases() {
        // Regular: add s
        assert_eq!(super::pluralize("user"), "users");
        assert_eq!(super::pluralize("device"), "devices");
        assert_eq!(super::pluralize("employee"), "employees");
        assert_eq!(super::pluralize("project"), "projects");
        assert_eq!(super::pluralize("server"), "servers");

        // Consonant + y → ies
        assert_eq!(super::pluralize("policy"), "policies");
        assert_eq!(super::pluralize("company"), "companies");
        assert_eq!(super::pluralize("category"), "categories");

        // Vowel + y → ys (NOT ies)
        assert_eq!(super::pluralize("relay"), "relays");
        assert_eq!(super::pluralize("day"), "days");
        assert_eq!(super::pluralize("key"), "keys");
        assert_eq!(super::pluralize("survey"), "surveys");

        // Sibilant endings → es
        assert_eq!(super::pluralize("batch"), "batches");
        assert_eq!(super::pluralize("bus"), "buses");
        assert_eq!(super::pluralize("box"), "boxes");
        assert_eq!(super::pluralize("quiz"), "quizes"); // simple rule, no consonant doubling
        assert_eq!(super::pluralize("flash"), "flashes");
    }
}
