use anyhow::Result;
use crate::ir::*;

pub fn generate(schema: &Schema) -> Result<String> {
    let mut output = String::new();
    
    // Header
    output.push_str("// Auto-generated by openerp-codegen\n");
    output.push_str("// DO NOT EDIT\n\n");
    
    output.push_str("use std::sync::Arc;\n");
    output.push_str("use async_trait::async_trait;\n");
    output.push_str("use axum::{\n");
    output.push_str("    Router,\n");
    output.push_str("    extract::{Path, Query, State},\n");
    output.push_str("    routing::{get, post, put, patch, delete},\n");
    output.push_str("    Json,\n");
    output.push_str("};\n");
    output.push_str("use serde::{Deserialize, Serialize};\n");
    output.push_str("use openerp_core::ServiceError;\n\n");
    
    // Generate type definitions
    for type_def in &schema.types {
        generate_type(&mut output, type_def);
    }
    
    // Generate service trait
    generate_service_trait(&mut output, &schema.service);
    
    // Generate router
    generate_router(&mut output, &schema.service);
    
    // Generate handlers
    for endpoint in &schema.service.endpoints {
        generate_handler(&mut output, endpoint, &schema.service.name);
    }
    
    Ok(output)
}

fn generate_type(output: &mut String, type_def: &TypeDef) {
    output.push_str(&format!("#[derive(Debug, Clone, Serialize, Deserialize)]\n"));
    output.push_str(&format!("pub struct {} {{\n", type_def.name));
    
    for field in &type_def.fields {
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type(&field.ty)));
    }
    
    output.push_str("}\n\n");
}

fn rust_type(ty: &Type) -> String {
    match ty {
        Type::String => "String".to_string(),
        Type::I32 => "i32".to_string(),
        Type::I64 => "i64".to_string(),
        Type::Bool => "bool".to_string(),
        Type::Option(inner) => format!("Option<{}>", rust_type(inner)),
        Type::Vec(inner) => format!("Vec<{}>", rust_type(inner)),
        Type::Custom(name) => name.clone(),
    }
}

fn generate_service_trait(output: &mut String, service: &Service) {
    output.push_str("#[async_trait]\n");
    output.push_str(&format!("pub trait {}: Send + Sync {{\n", service.name));
    
    for endpoint in &service.endpoints {
        if let Some(doc) = &endpoint.doc {
            output.push_str(&format!("    /// {}\n", doc));
        }
        
        output.push_str("    async fn ");
        output.push_str(&endpoint.name);
        output.push_str("(&self");
        
        // Add all params to trait method signature
        for param in &endpoint.params {
            output.push_str(&format!(", {}: {}", param.name, rust_type(&param.ty)));
        }
        
        output.push_str(") -> Result<");
        output.push_str(&rust_type(&endpoint.return_type));
        output.push_str(", ServiceError>;\n");
    }
    
    output.push_str("}\n\n");
}

fn generate_router(output: &mut String, service: &Service) {
    output.push_str(&format!("pub fn build_router<S: {} + 'static>(svc: Arc<S>) -> Router {{\n", service.name));
    output.push_str("    Router::new()\n");
    
    for endpoint in &service.endpoints {
        let method_fn = match endpoint.method {
            HttpMethod::GET => "get",
            HttpMethod::POST => "post",
            HttpMethod::PUT => "put",
            HttpMethod::PATCH => "patch",
            HttpMethod::DELETE => "delete",
        };
        
        output.push_str(&format!(
            "        .route(\"{}\", {}({}_handler::<S>))\n",
            endpoint.path, method_fn, endpoint.name
        ));
    }
    
    output.push_str("        .with_state(svc)\n");
    output.push_str("}\n\n");
}

fn generate_handler(output: &mut String, endpoint: &Endpoint, service_name: &str) {
    output.push_str(&format!("async fn {}_handler<S: {}>(", endpoint.name, service_name));
    
    // Extract params by kind
    let path_params: Vec<_> = endpoint.params.iter()
        .filter(|p| matches!(p.kind, ParamKind::Path))
        .collect();
    
    let query_params: Vec<_> = endpoint.params.iter()
        .filter(|p| matches!(p.kind, ParamKind::Query))
        .collect();
        
    let body_param = endpoint.params.iter()
        .find(|p| matches!(p.kind, ParamKind::Body));
    
    // Generate extractors
    let mut needs_newline = false;
    
    // Path extractor
    if !path_params.is_empty() {
        output.push_str("\n    Path((");
        for (i, param) in path_params.iter().enumerate() {
            if i > 0 { output.push_str(", "); }
            output.push_str(&param.name);
        }
        output.push_str(")): Path<(");
        for (i, param) in path_params.iter().enumerate() {
            if i > 0 { output.push_str(", "); }
            output.push_str(&rust_type(&param.ty));
        }
        output.push_str(")>,");
        needs_newline = true;
    }
    
    // Body extractor (must be before State)
    if let Some(body) = body_param {
        if needs_newline { output.push_str("\n    "); }
        output.push_str(&format!("Json({}): Json<{}>,", body.name, rust_type(&body.ty)));
        needs_newline = true;
    }
    
    // State extractor (always last)
    if needs_newline { output.push_str("\n    "); }
    output.push_str("State(svc): State<Arc<S>>,\n");
    
    output.push_str(") -> Result<Json<");
    output.push_str(&rust_type(&endpoint.return_type));
    output.push_str(">, ServiceError> {\n");
    
    // Extract query params into variables
    for param in &query_params {
        if let Some(default) = &param.default {
            output.push_str(&format!("    let {} = /* TODO: extract from query */ {};\n", param.name, default));
        }
    }
    
    // Call service method
    output.push_str(&format!("    let result = svc.{}(", endpoint.name));
    
    let mut first = true;
    for param in &endpoint.params {
        if !first { output.push_str(", "); }
        first = false;
        output.push_str(&param.name);
    }
    
    output.push_str(").await?;\n");
    output.push_str("    Ok(Json(result))\n");
    output.push_str("}\n\n");
}
