use anyhow::Result;
use crate::ir::*;

pub fn generate(schema: &Schema) -> Result<String> {
    let mut output = String::new();
    
    // Header
    output.push_str("// Auto-generated by openerp-codegen\n");
    output.push_str("// DO NOT EDIT\n\n");
    
    output.push_str("use serde::{Deserialize, Serialize};\n\n");
    
    // Generate type definitions (same as server)
    for type_def in &schema.types {
        output.push_str(&format!("#[derive(Debug, Clone, Serialize, Deserialize)]\n"));
        output.push_str(&format!("pub struct {} {{\n", type_def.name));
        
        for field in &type_def.fields {
            output.push_str(&format!("    pub {}: {},\n", field.name, rust_type(&field.ty)));
        }
        
        output.push_str("}\n\n");
    }
    
    // Generate client struct
    output.push_str(&format!("pub struct {}Client {{\n", schema.service.name));
    output.push_str("    base_url: String,\n");
    output.push_str("    client: reqwest::Client,\n");
    output.push_str("}\n\n");
    
    // Generate client impl
    output.push_str(&format!("impl {}Client {{\n", schema.service.name));
    output.push_str("    pub fn new(base_url: impl Into<String>) -> Self {\n");
    output.push_str("        Self {\n");
    output.push_str("            base_url: base_url.into(),\n");
    output.push_str("            client: reqwest::Client::new(),\n");
    output.push_str("        }\n");
    output.push_str("    }\n\n");
    
    // Generate client methods
    for endpoint in &schema.service.endpoints {
        generate_client_method(&mut output, endpoint);
    }
    
    output.push_str("}\n");
    
    Ok(output)
}

fn rust_type(ty: &Type) -> String {
    match ty {
        Type::String => "String".to_string(),
        Type::I32 => "i32".to_string(),
        Type::I64 => "i64".to_string(),
        Type::Bool => "bool".to_string(),
        Type::Option(inner) => format!("Option<{}>", rust_type(inner)),
        Type::Vec(inner) => format!("Vec<{}>", rust_type(inner)),
        Type::Custom(name) => name.clone(),
    }
}

fn generate_client_method(output: &mut String, endpoint: &Endpoint) {
    if let Some(doc) = &endpoint.doc {
        output.push_str(&format!("    /// {}\n", doc));
    }
    
    output.push_str(&format!("    pub async fn {}(&self", endpoint.name));
    
    for param in &endpoint.params {
        output.push_str(&format!(", {}: {}", param.name, rust_type(&param.ty)));
    }
    
    output.push_str(") -> Result<");
    output.push_str(&rust_type(&endpoint.return_type));
    output.push_str(", reqwest::Error> {\n");
    
    // Build URL
    output.push_str("        let url = format!(\"{}/{}\", self.base_url, \"");
    
    let mut path = endpoint.path.clone();
    for param in &endpoint.params {
        if matches!(param.kind, ParamKind::Path) {
            path = path.replace(&format!(":{}",param.name), &format!("{{{}}}", param.name));
        }
    }
    output.push_str(&path.trim_start_matches('/'));
    output.push_str("\"");
    
    for param in &endpoint.params {
        if matches!(param.kind, ParamKind::Path) {
            output.push_str(&format!(", {} = {}", param.name, param.name));
        }
    }
    
    output.push_str(");\n");
    
    // Build request
    let method = match endpoint.method {
        HttpMethod::GET => "get",
        HttpMethod::POST => "post",
        HttpMethod::PUT => "put",
        HttpMethod::PATCH => "patch",
        HttpMethod::DELETE => "delete",
    };
    
    output.push_str(&format!("        let resp = self.client.{}(&url)", method));
    
    // Add body
    if let Some(body_param) = endpoint.params.iter().find(|p| matches!(p.kind, ParamKind::Body)) {
        output.push_str(&format!(".json(&{})", body_param.name));
    }
    
    output.push_str("\n            .send()\n");
    output.push_str("            .await?\n");
    output.push_str("            .error_for_status()?;\n");
    
    // Parse response
    if rust_type(&endpoint.return_type) == "()" {
        output.push_str("        Ok(())\n");
    } else {
        output.push_str("        resp.json().await\n");
    }
    
    output.push_str("    }\n\n");
}
