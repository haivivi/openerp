//! `#[flux_handlers]` macro expansion.
//!
//! Scans an `impl` block for methods annotated with `#[handle(ReqType)]`.
//! Generates a `register(self: &Arc<Self>, flux: &Flux)` method that wires
//! each handler to the Flux router with automatic payload downcast.
//!
//! Input:
//! ```ignore
//! #[flux_handlers]
//! impl TwitterBff {
//!     #[handle(LoginReq)]
//!     pub async fn handle_login(&self, req: &LoginReq, store: &StateStore) {
//!         // ...
//!     }
//! }
//! ```
//!
//! Output: original impl block preserved + a new impl block with `register()`:
//! ```ignore
//! impl TwitterBff {
//!     pub async fn handle_login(&self, req: &LoginReq, store: &StateStore) { ... }
//! }
//!
//! impl TwitterBff {
//!     pub fn register(self: &::std::sync::Arc<Self>, flux: &::openerp_flux::Flux) {
//!         {
//!             let this = ::std::sync::Arc::clone(self);
//!             flux.on(<LoginReq>::PATH, move |_, payload, store: ::std::sync::Arc<::openerp_flux::StateStore>| {
//!                 let this = this.clone();
//!                 async move {
//!                     let req = payload.downcast_ref::<LoginReq>().unwrap();
//!                     this.handle_login(req, &store).await;
//!                 }
//!             });
//!         }
//!     }
//! }
//! ```

use proc_macro2::TokenStream;
use quote::quote;
use syn::{ImplItem, ItemImpl};

/// A discovered handler: method name + request type.
struct HandlerInfo {
    method_name: syn::Ident,
    req_type: syn::Path,
}

pub fn expand(item: ItemImpl) -> syn::Result<TokenStream> {
    let self_ty = &item.self_ty;

    // Collect handlers: methods with #[handle(ReqType)] attribute.
    let mut handlers = Vec::new();

    // Clean impl items: strip #[handle(...)] attributes from methods.
    let mut clean_items = Vec::new();
    for item in &item.items {
        match item {
            ImplItem::Fn(method) => {
                let info = extract_handle_attr(method)?;
                let mut clean_method = method.clone();
                // Remove #[handle(...)] attribute.
                clean_method.attrs.retain(|a| !a.path().is_ident("handle"));
                clean_items.push(ImplItem::Fn(clean_method));
                if let Some(info) = info {
                    handlers.push(info);
                }
            }
            other => {
                clean_items.push(other.clone());
            }
        }
    }

    // Generate registration blocks.
    let registrations: Vec<TokenStream> = handlers.iter().map(|h| {
        let method_name = &h.method_name;
        let req_type = &h.req_type;

        quote! {
            {
                let this = ::std::sync::Arc::clone(self);
                flux.on(<#req_type>::PATH, move |_, payload, store: ::std::sync::Arc<::openerp_flux::StateStore>| {
                    let this = this.clone();
                    async move {
                        let req = payload.downcast_ref::<#req_type>().unwrap();
                        this.#method_name(req, &store).await;
                    }
                });
            }
        }
    }).collect();

    // Collect generics and other impl attrs.
    let attrs: Vec<_> = item.attrs.iter().collect();
    let generics = &item.generics;

    Ok(quote! {
        // Original impl block (with #[handle] attrs stripped).
        #(#attrs)*
        impl #generics #self_ty {
            #(#clean_items)*
        }

        // Generated register method.
        impl #generics #self_ty {
            /// Register all `#[handle]` methods with the Flux router.
            ///
            /// Generated by `#[flux_handlers]`.
            pub fn register(self: &::std::sync::Arc<Self>, flux: &::openerp_flux::Flux) {
                #(#registrations)*
            }
        }
    })
}

/// Extract `#[handle(ReqType)]` from a method, if present.
fn extract_handle_attr(method: &syn::ImplItemFn) -> syn::Result<Option<HandlerInfo>> {
    for attr in &method.attrs {
        if attr.path().is_ident("handle") {
            let req_type: syn::Path = attr.parse_args()?;
            return Ok(Some(HandlerInfo {
                method_name: method.sig.ident.clone(),
                req_type,
            }));
        }
    }
    Ok(None)
}
