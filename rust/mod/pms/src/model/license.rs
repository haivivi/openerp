use serde::{Deserialize, Serialize};

/// License source.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum LicenseSource {
    Import,
    Generate,
}

/// License status.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum LicenseStatus {
    Available,
    Allocated,
}

impl Default for LicenseStatus {
    fn default() -> Self {
        Self::Available
    }
}

/// License â€” multi-type license. Composite PK: type + number.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct License {
    /// Internal ID (type/number composite key serialized).
    #[serde(default)]
    pub id: String,

    /// License type (e.g. "MIIT", "FCC", "CE").
    #[serde(rename = "type")]
    pub license_type: String,

    /// License number.
    pub number: String,

    /// Source: imported externally or generated by system.
    pub source: LicenseSource,

    /// Assigned device SN (None = available in pool).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sn: Option<String>,

    /// Import record this license belongs to.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub import_id: Option<String>,

    /// License lifecycle status.
    #[serde(default)]
    pub status: LicenseStatus,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub display_name: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_at: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub update_at: Option<String>,
}

impl License {
    /// Composite key for license: "{type}/{number}".
    pub fn composite_key(license_type: &str, number: &str) -> String {
        format!("{}/{}", license_type, number)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn license_json_roundtrip() {
        let lic = License {
            id: "MIIT/MIIT-2025-000001".into(),
            license_type: "MIIT".into(),
            number: "MIIT-2025-000001".into(),
            source: LicenseSource::Import,
            sn: Some("HVV-XXXXX-XXX-XXXX-X".into()),
            import_id: Some("import001".into()),
            status: LicenseStatus::Allocated,
            display_name: None,
            description: None,
            data: None,
            create_at: None,
            update_at: None,
        };
        let json = serde_json::to_string(&lic).unwrap();
        let back: License = serde_json::from_str(&json).unwrap();
        assert_eq!(lic, back);
    }
}
