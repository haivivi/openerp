//! Auth module v2 — built with the DSL framework.
//!
//! DSL model definitions in `dsl/model/`.
//! KvStore impls + hooks in this file.
//! Custom handlers in `src/handlers/`.

// DSL definitions.
#[path = "../dsl/model/mod.rs"]
pub mod model;
#[path = "../dsl/ui/mod.rs"]
pub mod ui_defs;

pub mod handlers;
mod store_impls;

use std::sync::Arc;

use axum::Router;
use openerp_store::{admin_kv_router, KvOps, KvStore};

use model::*;

/// Build the admin router for all auth resources.
pub fn admin_router(
    kv: Arc<dyn openerp_kv::KVStore>,
    auth: Arc<dyn openerp_core::Authenticator>,
) -> Router {
    let mut router = Router::new();

    router = router.merge(admin_kv_router(
        KvOps::<User>::new(kv.clone()), auth.clone(), "auth", "users", "user",
    ));
    router = router.merge(admin_kv_router(
        KvOps::<Role>::new(kv.clone()), auth.clone(), "auth", "roles", "role",
    ));
    router = router.merge(admin_kv_router(
        KvOps::<Group>::new(kv.clone()), auth.clone(), "auth", "groups", "group",
    ));
    router = router.merge(admin_kv_router(
        KvOps::<Policy>::new(kv.clone()), auth.clone(), "auth", "policies", "policy",
    ));
    router = router.merge(admin_kv_router(
        KvOps::<Session>::new(kv.clone()), auth.clone(), "auth", "sessions", "session",
    ));
    router = router.merge(admin_kv_router(
        KvOps::<Provider>::new(kv.clone()), auth.clone(), "auth", "providers", "provider",
    ));

    router
}

/// Get UI widget overrides defined in dsl/ui/.
pub fn ui_overrides() -> Vec<openerp_store::WidgetOverride> {
    ui_defs::overrides()
}

/// Build schema definition for this module.
/// Auto-derived from #[model] IR — no hand-written field lists.
pub fn schema_def() -> openerp_store::ModuleDef {
    use openerp_store::ResourceDef;
    openerp_store::ModuleDef {
        id: "auth",
        label: "Authentication",
        icon: "shield",
        resources: vec![
            ResourceDef::from_ir("auth", User::__dsl_ir()),
            ResourceDef::from_ir("auth", Role::__dsl_ir()),
            ResourceDef::from_ir("auth", Group::__dsl_ir()),
            ResourceDef::from_ir("auth", Policy::__dsl_ir()),
            ResourceDef::from_ir("auth", Session::__dsl_ir()),
            ResourceDef::from_ir("auth", Provider::__dsl_ir()),
        ],
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;

    #[test]
    fn user_kv_crud() {
        let dir = tempfile::tempdir().unwrap();
        let kv: Arc<dyn openerp_kv::KVStore> = Arc::new(
            openerp_kv::RedbStore::open(&dir.path().join("test.redb")).unwrap(),
        );
        let ops = KvOps::<User>::new(kv);

        let user = User {
            id: openerp_types::Id::default(),
            name: "Alice".into(),
            email: Some(openerp_types::Email::new("alice@test.com")),
            avatar: None,
            active: true,
            password_hash: None,
            linked_accounts: None,
            metadata: None,
            created_at: openerp_types::DateTime::default(),
            updated_at: openerp_types::DateTime::default(),
        };

        let created = ops.save_new(user).unwrap();
        assert!(!created.id.is_empty(), "ID auto-generated by before_create");
        assert!(!created.created_at.is_empty(), "created_at auto-filled");

        let fetched = ops.get_or_err(created.id.as_str()).unwrap();
        assert_eq!(fetched.name, "Alice");

        let all = ops.list().unwrap();
        assert_eq!(all.len(), 1);
    }

    #[test]
    fn role_kv_crud() {
        let dir = tempfile::tempdir().unwrap();
        let kv: Arc<dyn openerp_kv::KVStore> = Arc::new(
            openerp_kv::RedbStore::open(&dir.path().join("test2.redb")).unwrap(),
        );
        let ops = KvOps::<Role>::new(kv);

        let role = Role {
            id: openerp_types::Id::new("pms:admin"),
            description: Some("PMS admin".into()),
            permissions: vec!["pms:device:read".into(), "pms:device:write".into()],
            service: Some("pms".into()),
            created_at: openerp_types::DateTime::default(),
            updated_at: openerp_types::DateTime::default(),
        };

        let created = ops.save_new(role).unwrap();
        assert_eq!(created.id.as_str(), "pms:admin");
        assert_eq!(created.permissions.len(), 2);
    }

    #[test]
    fn schema_def_has_all_resources() {
        let def = schema_def();
        assert_eq!(def.id, "auth");
        assert_eq!(def.resources.len(), 6);
        assert_eq!(def.resources[0].name, "user");
        assert_eq!(def.resources[0].permissions.len(), 5);
    }

    #[tokio::test]
    async fn admin_router_responds() {
        use axum::body::Body;
        use axum::http::{Request, StatusCode};
        use tower::ServiceExt;

        let dir = tempfile::tempdir().unwrap();
        let kv: Arc<dyn openerp_kv::KVStore> = Arc::new(
            openerp_kv::RedbStore::open(&dir.path().join("test3.redb")).unwrap(),
        );
        let auth: Arc<dyn openerp_core::Authenticator> = Arc::new(openerp_core::AllowAll);
        let router = admin_router(kv, auth);

        // GET /users should return empty list.
        let req = Request::builder()
            .uri("/users")
            .body(Body::empty())
            .unwrap();
        let resp = router.clone().oneshot(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::OK);

        let body = axum::body::to_bytes(resp.into_body(), 1024 * 1024).await.unwrap();
        let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(json["total"], 0);
        assert_eq!(json["items"].as_array().unwrap().len(), 0);

        // POST /users to create.
        let user_json = serde_json::json!({
            "name": "Bob",
            "email": "bob@test.com",
            "active": true,
        });
        let req = Request::builder()
            .method("POST")
            .uri("/users")
            .header("content-type", "application/json")
            .body(Body::from(serde_json::to_string(&user_json).unwrap()))
            .unwrap();
        let resp = router.clone().oneshot(req).await.unwrap();
        assert_eq!(resp.status(), StatusCode::OK);

        let body = axum::body::to_bytes(resp.into_body(), 1024 * 1024).await.unwrap();
        let created: serde_json::Value = serde_json::from_slice(&body).unwrap();
        assert_eq!(created["name"], "Bob");
        assert!(!created["id"].as_str().unwrap().is_empty());
    }
}
