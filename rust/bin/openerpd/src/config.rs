//! Server-side configuration parser.
//!
//! Reads `/etc/openerp/<context>.toml` (or the path given with `-c`).
//! The file is generated by `openerp context create`.

use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};

/// Root section — virtual superadmin account.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RootConfig {
    /// argon2id password hash
    pub password_hash: String,
}

/// Storage section — where data lives on disk.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    /// Root data directory for all embedded stores.
    pub data_dir: String,
}

/// JWT section — token signing.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JwtConfig {
    /// HMAC secret (randomly generated at install time).
    pub secret: String,

    /// Token expiration in seconds (default: 86400 = 24h).
    #[serde(default = "default_expire_secs")]
    pub expire_secs: u64,
}

fn default_expire_secs() -> u64 {
    86400
}

/// Top-level server configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub root: RootConfig,
    pub storage: StorageConfig,
    pub jwt: JwtConfig,
}

impl ServerConfig {
    /// Load configuration from a TOML file.
    pub fn load(path: &Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| anyhow::anyhow!("failed to read config {}: {}", path.display(), e))?;
        let config: ServerConfig = toml::from_str(&content)
            .map_err(|e| anyhow::anyhow!("failed to parse config {}: {}", path.display(), e))?;
        Ok(config)
    }

    /// Resolve the config file path from a context name.
    ///
    /// If `context_or_path` contains a `/` or `.`, treat it as a path.
    /// Otherwise, look up `/etc/openerp/{context_or_path}.toml`.
    pub fn resolve_path(context_or_path: &str) -> PathBuf {
        if context_or_path.contains('/') || context_or_path.contains('.') {
            PathBuf::from(context_or_path)
        } else {
            PathBuf::from(format!("/etc/openerp/{}.toml", context_or_path))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_resolve_path_context_name() {
        let p = ServerConfig::resolve_path("cn-stage");
        assert_eq!(p, PathBuf::from("/etc/openerp/cn-stage.toml"));
    }

    #[test]
    fn test_resolve_path_explicit() {
        let p = ServerConfig::resolve_path("/tmp/my-config.toml");
        assert_eq!(p, PathBuf::from("/tmp/my-config.toml"));
    }

    #[test]
    fn test_parse_config() {
        let toml_str = r#"
[root]
password_hash = "$argon2id$v=19$m=65536,t=3,p=4$salt$hash"

[storage]
data_dir = "/var/lib/openerp/test"

[jwt]
secret = "test-secret-256-bits"
expire_secs = 3600
"#;
        let config: ServerConfig = toml::from_str(toml_str).unwrap();
        assert_eq!(config.storage.data_dir, "/var/lib/openerp/test");
        assert_eq!(config.jwt.expire_secs, 3600);
        assert!(config.root.password_hash.starts_with("$argon2id"));
    }
}
